@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Logging
@using PlusUi.core
@using SkiaSharp
@using SkiaSharp.Views.Blazor
@using System.Numerics
@inject RenderService RenderService
@inject InputService InputService
@inject NavigationContainer NavigationContainer
@inject PlusUiNavigationService NavigationService
@inject ILogger<PlusUiRootComponent> Logger

<div class="plusui-container" @ref="_containerRef">
    <SKCanvasView @ref="_canvasView"
                  OnPaintSurface="OnPaintSurface"
                  @onpointerdown="HandlePointerDown"
                  @onpointermove="HandlePointerMove"
                  @onpointerup="HandlePointerUp"
                  @onwheel="HandleWheel"
                  @onkeydown="HandleKeyDown"
                  @onkeyup="HandleKeyUp"
                  tabindex="0"
                  style="width: 100%; height: 100vh; outline: none; display: block;" />
</div>

@code {
    private SKCanvasView? _canvasView;
    private ElementReference _containerRef;
    private int _width;
    private int _height;
    private bool _isInitialized;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeAsync();
        }
    }

    private async Task InitializeAsync()
    {
        try
        {
            // Get initial canvas size from browser
            // In a real implementation, you'd use JSInterop to get actual viewport size
            _width = 1920;  // Default size, will be updated on first paint
            _height = 1080;

            // Set display density (for HiDPI screens)
            // In production, get this from JSInterop: window.devicePixelRatio
            RenderService.DisplayDensity = 1.0f;

            // Initialize navigation (loads root page)
            NavigationService.Initialize();

            _isInitialized = true;

            // Force initial render
            StateHasChanged();

            Logger.LogInformation("PlusUi Web initialized with size {Width}x{Height}", _width, _height);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize PlusUi Web");
        }
    }

    private void OnPaintSurface(SKPaintSurfaceEventArgs e)
    {
        if (!_isInitialized)
        {
            return;
        }

        var surface = e.Surface;
        var canvas = surface.Canvas;
        
        // Update size if canvas size changed
        if (_width != e.Info.Width || _height != e.Info.Height)
        {
            _width = e.Info.Width;
            _height = e.Info.Height;
            NavigationContainer.CurrentPage.InvalidateMeasure();
            Logger.LogDebug("Canvas resized to {Width}x{Height}", _width, _height);
        }

        try
        {
            // Call the platform-agnostic render service
            // Note: We pass null for GL and GRContext since Blazor SkiaSharp handles this internally
            RenderService.Render(
                clearAction: null,
                canvas: canvas,
                grContext: null,
                canvasSize: new Vector2(_width, _height));
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during rendering");
        }
    }

    private void HandlePointerDown(PointerEventArgs e)
    {
        var position = new Vector2((float)e.OffsetX, (float)e.OffsetY);
        InputService.MouseDown(position / RenderService.DisplayDensity);
        RequestRender();
    }

    private void HandlePointerMove(PointerEventArgs e)
    {
        var position = new Vector2((float)e.OffsetX, (float)e.OffsetY);
        InputService.MouseMove(position / RenderService.DisplayDensity);
        RequestRender();
    }

    private void HandlePointerUp(PointerEventArgs e)
    {
        var position = new Vector2((float)e.OffsetX, (float)e.OffsetY);
        InputService.MouseUp(position / RenderService.DisplayDensity);
        RequestRender();
    }

    private void HandleWheel(WheelEventArgs e)
    {
        // Note: Browser wheel events use deltaY for vertical scroll
        // We need to invert and scale similar to desktop implementation
        float scrollSpeed = 20f;
        float deltaX = (float)e.DeltaX;
        float deltaY = -(float)e.DeltaY; // Invert for natural scrolling
        
        var position = new Vector2((float)e.OffsetX, (float)e.OffsetY);
        InputService.MouseWheel(
            position / RenderService.DisplayDensity,
            deltaX * scrollSpeed,
            deltaY * scrollSpeed);
        
        RequestRender();
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        Logger.LogDebug("Key down: {Key}", e.Key);
    }

    private void HandleKeyUp(KeyboardEventArgs e)
    {
        Logger.LogDebug("Key up: {Key}", e.Key);
    }

    private void RequestRender()
    {
        // In Blazor, we need to trigger a state change to re-render
        InvokeAsync(StateHasChanged);
    }
}
